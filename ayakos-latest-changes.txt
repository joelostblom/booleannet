commit 1c3d26878cccb541d27840e8939309556fc0c8cc
Author: joelostblom <joel.ostblom@gmail.com>
Date:   Thu Jul 7 17:19:37 2016 -0400

    ayakos latest changes, now installing works

diff --git a/.gitignore b/.gitignore
index 8b3234f..1a38c6a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,6 @@
 build/
 dist/
 BooleanNet.egg-info/
+*__pycache__*
+*gml
+*log
diff --git a/boolean2/__init__.py b/boolean2/__init__.py
index 44e0d84..9f294e2 100644
--- a/boolean2/__init__.py
+++ b/boolean2/__init__.py
@@ -6,7 +6,8 @@ import sys, re, os
 
 __VERSION__ = '1.2.0-beta'
 
-from . import util
+#from . import util
+import boolean2.util
 
 # require python 2.4 or higher
 if sys.version_info[:2] < (2, 5):
@@ -16,12 +17,14 @@ from . import ruleparser, boolmodel, timemodel, tokenizer
 
 from .tokenizer import modify_states
 
-def Model( text, mode):
+def Model(text, mode):
     "Factory function that returns the proper class based on the mode"
 
     # the text parameter may be a file that contains the rules
     if os.path.isfile( text ):
-        text = file(text, 'rt').read()
+        #text = file(text, 'rt').read()
+        text = open(text, 'rt').read()
+        print("+++++")
 
     # check the validity of modes
     if mode not in ruleparser.VALID_MODES:
@@ -58,7 +61,7 @@ def test():
     model.initialize(  )
     model.iterate( steps=10, fullt=2)
     
-    print(all_nodes ( text ))
+    print((all_nodes ( text )))
     #for i in range(12):
     #    print model.next()
 
diff --git a/boolean2/boolmodel.py b/boolean2/boolmodel.py
index b5a704b..6256fd3 100644
--- a/boolean2/boolmodel.py
+++ b/boolean2/boolmodel.py
@@ -126,11 +126,11 @@ class BoolModel(Parser):
         index, size = self.detect_cycles()
         
         if size == 0:
-            print("No cycle or steady state could be detected from the %d states" % len(self.states))
+            print(("No cycle or steady state could be detected from the %d states" % len(self.states)))
         elif size==1:
-            print("Steady state starting at index %s -> %s" % (index, self.states[index] ))
+            print(("Steady state starting at index %s -> %s" % (index, self.states[index] )))
         else:
-            print("Cycle of length %s starting at index %s" % (size, index))
+            print(("Cycle of length %s starting at index %s" % (size, index)))
     
     def fp(self):
         "The models current fingerprint"
@@ -154,18 +154,18 @@ if __name__ == '__main__':
 
     model.initialize(  )
         
-    print('>>>', model.first)
+    print(('>>>', model.first))
 
     model.iterate( steps=2 )
     
-    print(model.fp())
+    print((model.fp()))
     model.report_cycles()
     model.save_states( fname='states.txt' )
 
     # detect cycles from a list of states
     states = ['S1', 'S2', 'S1', 'S2', 'S1', 'S2']
     print() 
-    print('States %s -> Detect cycles %s' % (states, util.detect_cycles( states ) ))
+    print(('States %s -> Detect cycles %s' % (states, util.detect_cycles( states ) )))
 
 
        
\ No newline at end of file
diff --git a/boolean2/network.py b/boolean2/network.py
index 0aa39aa..2abbf89 100644
--- a/boolean2/network.py
+++ b/boolean2/network.py
@@ -4,7 +4,7 @@ from itertools import count
 
 try:
     import networkx
-    from networkx import component
+    from networkx import components
 except ImportError:
     util.error( "networkx is missing, install it from https://networkx.lanl.gov/")
 
@@ -24,15 +24,16 @@ def component_colormap(graph):
     colors = [ ORANGE, SPRING_GREEN, GOLD, TEAL, PURPLE, NAVY, SIENNA, CRIMSON, BLUE, ]
     
     # find the strongly connected components
-    components = component.strongly_connected_components( graph )
+    components2 = components.strongly_connected_components( graph )
     
     # make sure we have as many colors as components
-    if len(colors) < len(components):
-        util.warn( 'there are more components than colors!' )
+    ##print( components2 )
+    ##if len(colors) < len(components2):
+    ##    util.warn( 'there are more components than colors!' )
 
     # create the colormap
     colormap = {}
-    for color, comp in  zip(colors, components):
+    for color, comp in  zip(colors, components2):
         for node in comp:
             colormap[node] = color
     return colormap
diff --git a/boolean2/ply/yacc.py b/boolean2/ply/yacc.py
index c37ce5a..29e0a2b 100644
--- a/boolean2/ply/yacc.py
+++ b/boolean2/ply/yacc.py
@@ -519,7 +519,12 @@ def initialize_vars():
 
     Errorfunc    = None    # User defined error handler
 
-    Signature    = hashlib.new('md5')   # Digital signature of the grammar rules, precedence
+    #Signature    = hashlib.new('md5')   # Digital signature of the grammar rules, precedence
+
+
+
+
+    Signature    = hashlib.md5()   # Digital signature of the grammar rules, precedence
                                # and other information.  Used to determined when a
                                # parsing table needs to be regenerated.
 
diff --git a/boolean2/state.py b/boolean2/state.py
index 0da52da..a29cc6d 100644
--- a/boolean2/state.py
+++ b/boolean2/state.py
@@ -147,5 +147,5 @@ if __name__ == '__main__':
     gen = all_initial_states(nodes)
 
     for data, func in gen:
-        print(list(map(func, nodes)))
+        print((list(map(func, nodes))))
 
diff --git a/boolean2/timemodel.py b/boolean2/timemodel.py
index 30eb628..ddf6b3a 100644
--- a/boolean2/timemodel.py
+++ b/boolean2/timemodel.py
@@ -82,4 +82,4 @@ if __name__ == '__main__':
         tstamp = 'T=%d ' % t
         data = [ tstamp ] + list(map(int, (state.A, state.B, state.C, state.D)))
         data = list(map(str, data))
-        print('\t'.join(data))
+        print(('\t'.join(data)))
diff --git a/boolean2/tokenizer.py b/boolean2/tokenizer.py
index 0a05e10..911135e 100644
--- a/boolean2/tokenizer.py
+++ b/boolean2/tokenizer.py
@@ -4,9 +4,10 @@ Main tokenizer.
 from itertools import *
 import sys, random
 from . import util
-#from . import ply.lex as lex
+#import boolean2.util
 import ply.lex as lex
 
+
 class Lexer:
     """
     Lexer for boolean rules
@@ -231,6 +232,6 @@ if __name__ == '__main__':
 
     """
     
-    print(modify_states( text, turnon=['A', 'B'], turnoff=['C'] ))
+    print((modify_states( text, turnon=['A', 'B'], turnoff=['C'] )))
 
     
diff --git a/boolean2/util.py b/boolean2/util.py
index a03ea02..98ab5aa 100644
--- a/boolean2/util.py
+++ b/boolean2/util.py
@@ -18,12 +18,12 @@ def join( data, sep="\t", patt="%s\n"):
 
 def error(msg):
     "Prints an error message and stops"
-    print('*** error: %s' % msg)
+    print(('*** error: %s' % msg))
     sys.exit()
 
 def warn(msg):
     "Prints a warning message"
-    print('*** warning: %s' % msg)
+    print(('*** warning: %s' % msg))
  
 def tuple_to_bool( value ):
     """
diff --git a/examples/projects/demos/demo-override.py b/examples/projects/demos/demo-override.py
index 2a8c2c1..0bd893b 100644
--- a/examples/projects/demos/demo-override.py
+++ b/examples/projects/demos/demo-override.py
@@ -41,4 +41,4 @@ model.initialize()
 model.iterate( steps=5 )
 
 for state in model.states:
-    print state
\ No newline at end of file
+    print(state)
\ No newline at end of file
diff --git a/examples/projects/demos/demo-sync.py b/examples/projects/demos/demo-sync.py
index a27781c..8e2dec8 100644
--- a/examples/projects/demos/demo-sync.py
+++ b/examples/projects/demos/demo-sync.py
@@ -26,13 +26,13 @@ model.iterate( steps=5 )
 
 # you can print the states
 for state in model.states:
-    print state
+    print(state)
 
-print '-' * 20
+print('-' * 20)
 
 # save states into a file
 model.save_states( 'states.txt' )
 
 # two ways to access nodes for a state
 for state in model.states:
-    print state['A'], state.A
\ No newline at end of file
+    print(state['A'], state.A)
\ No newline at end of file
diff --git a/examples/projects/immune/Bb-plot.py b/examples/projects/immune/Bb-plot.py
index 4bfda62..4313efb 100644
--- a/examples/projects/immune/Bb-plot.py
+++ b/examples/projects/immune/Bb-plot.py
@@ -13,7 +13,7 @@ def skip( data, step=10):
         return data[::step]
     
     out = dict()
-    for key, values in data.items():
+    for key, values in list(data.items()):
         values = values[::step]
         out[key] = values
     return out
diff --git a/examples/projects/immune/localdefs.py b/examples/projects/immune/localdefs.py
index eb683b5..70e32ea 100644
--- a/examples/projects/immune/localdefs.py
+++ b/examples/projects/immune/localdefs.py
@@ -90,4 +90,4 @@ def positive(x):
 
 if __name__ == '__main__':
     for i in range(10):
-        print slow_sticky_prop( label='A', rc=10, r=1, t=i)
\ No newline at end of file
+        print(slow_sticky_prop( label='A', rc=10, r=1, t=i))
\ No newline at end of file
diff --git a/examples/samples/all-initial-states.py b/examples/samples/all-initial-states.py
index b059a7b..563a463 100644
--- a/examples/samples/all-initial-states.py
+++ b/examples/samples/all-initial-states.py
@@ -19,6 +19,6 @@ initializer = state.all_initial_states( model.nodes, limit=None )
 # the data is the inital data, the func is the initializer
 for data, initfunc in initializer:
     # shows the initial values
-    print data
+    print(data)
     model.initialize(missing=initfunc)
     model.iterate(5)
diff --git a/examples/samples/extend-getvalue.py b/examples/samples/extend-getvalue.py
index 0b0a731..e622873 100644
--- a/examples/samples/extend-getvalue.py
+++ b/examples/samples/extend-getvalue.py
@@ -23,7 +23,7 @@ def get_value( state, name, p ):
 
     # detect the node of interest
     if name == 'B':
-        print 'now getting node %s' % name 
+        print('now getting node %s' % name) 
         return random.choice ( (True, False) )
     else:
         # returns the normal value
@@ -35,4 +35,4 @@ model.initialize()
 model.iterate( steps=5 )
 
 for state in model.states:
-    print state.A, state.B, state.C
\ No newline at end of file
+    print(state.A, state.B, state.C)
\ No newline at end of file
diff --git a/examples/samples/extend-rules.py b/examples/samples/extend-rules.py
index b30abb6..91675e5 100644
--- a/examples/samples/extend-rules.py
+++ b/examples/samples/extend-rules.py
@@ -40,4 +40,4 @@ model.initialize()
 model.iterate( steps=5 )
 
 for state in model.states:
-    print state.A, state.B, state.C
\ No newline at end of file
+    print(state.A, state.B, state.C)
\ No newline at end of file
diff --git a/examples/samples/extend-setvalue.py b/examples/samples/extend-setvalue.py
index 29ceee4..ccb99aa 100644
--- a/examples/samples/extend-setvalue.py
+++ b/examples/samples/extend-setvalue.py
@@ -23,7 +23,7 @@ def set_value( state, name, value, p ):
 
     # detect the node of interest
     if name == 'B':
-        print 'now setting node %s' % name 
+        print('now setting node %s' % name) 
         value = random.choice ( (True, False) )
     
     # this sets the attribute
@@ -36,4 +36,4 @@ model.initialize()
 model.iterate( steps=5 )
 
 for state in model.states:
-    print state.A, state.B, state.C
\ No newline at end of file
+    print(state.A, state.B, state.C)
\ No newline at end of file
diff --git a/examples/samples/singlepick.py b/examples/samples/singlepick.py
index ab9e955..44c8c43 100644
--- a/examples/samples/singlepick.py
+++ b/examples/samples/singlepick.py
@@ -29,7 +29,7 @@ def simulation( trans ):
     for data, initfunc in initializer:
         model.initialize(missing=initfunc)
         model.iterate(15, shuffler=mypick)
-        trans.add( model.states, times=range(15) )
+        trans.add( model.states, times=list(range(15)) )
 
 def main():
     "This is the main code that runs the simulation many times"
diff --git a/examples/samples/threenodes.py b/examples/samples/threenodes.py
index cda0c1a..b1699aa 100644
--- a/examples/samples/threenodes.py
+++ b/examples/samples/threenodes.py
@@ -22,7 +22,7 @@ def simulation( trans ):
     for data, initfunc in initializer:
         model.initialize(missing=initfunc)
         model.iterate(5)
-        trans.add( model.states, times=range(5) )
+        trans.add( model.states, times=list(range(5)) )
 
 def main():
     "This is the main code that runs the simulation many times"
diff --git a/examples/samples/timemodel.py b/examples/samples/timemodel.py
index 30a2450..da91822 100644
--- a/examples/samples/timemodel.py
+++ b/examples/samples/timemodel.py
@@ -34,7 +34,7 @@ def simulation( ):
     for data, initfunc in initializer:
         model.initialize( missing=initfunc )
         model.iterate( 12 )
-        trans.add( model.states, times=range(12) )
+        trans.add( model.states, times=list(range(12)) )
 
     # saves the transition graph into a gml file
     trans.save( 'timemodel.gml' )
diff --git a/examples/tutorials/t-01.py b/examples/tutorials/t-01.py
index b461308..ba4e1c9 100644
--- a/examples/tutorials/t-01.py
+++ b/examples/tutorials/t-01.py
@@ -1,21 +1,22 @@
-from boolean2 import Model
-
-text = """
-# initial values
-A = B = C = True
-
-# updating rules
-
-A* = A and C
-B* = A and B
-C* = not A
-"""
-
-model = Model( text=text, mode='sync')
-model.initialize()
-model.iterate( steps=5 )
-
-for state in model.states:
-    print state.A, state.B, state.C
-
-
+from boolean2 import Model
+
+
+text = """
+# initial values
+A = B = C = True
+
+# updating rules
+
+A* = A and C
+B* = A and B
+C* = not A
+"""
+
+model = Model( text=text, mode='sync')
+model.initialize()
+model.iterate( steps=5 )
+
+for state in model.states:
+    print(state.A, state.B, state.C)
+
+
diff --git a/examples/tutorials/t-02.py b/examples/tutorials/t-02.py
index 27bbc9c..606d932 100644
--- a/examples/tutorials/t-02.py
+++ b/examples/tutorials/t-02.py
@@ -1,48 +1,48 @@
-import pylab
-from boolean2 import Model
-
-#
-# This initial condition leads to a cycle of period 4.
-# If A is set to False, a steady state is obtained.
-#
-# 
-text = """
-A = True
-B = False
-C = False
-D = True
-
-B* = A or C
-C* = A and not D
-D* = B and C
-"""
-
-model = Model( text=text, mode='sync')
-model.initialize()
-model.iterate( steps=15 )
-
-# the model data attribute holds the states keyed by nodes
-for node in model.data:
-    print node, model.data[node]
-
-# this is a helper function that reports the cycle lengths 
-# and the  index at wich the cycle started
-model.report_cycles()
-
-#
-# the same thing as above but
-# will not print only return the two parameters
-#
-print model.detect_cycles()    
-
-#
-# this is how one plots the values, delete this below
-# if matplotlib is not installed
-#
-p1 = pylab.plot( model.data["B"] , 'ob-' )
-p2 = pylab.plot( model.data["C"] , 'sr-' )
-pylab.legend( [p1,p2], ["B","C"])
-pylab.ylim((-0.1,1.1))
-pylab.show()    
-
-
+import pylab
+from boolean2 import Model
+
+#
+# This initial condition leads to a cycle of period 4.
+# If A is set to False, a steady state is obtained.
+#
+# 
+text = """
+A = True
+B = False
+C = False
+D = True
+
+B* = A or C
+C* = A and not D
+D* = B and C
+"""
+
+model = Model( text=text, mode='sync')
+model.initialize()
+model.iterate( steps=15 )
+
+# the model data attribute holds the states keyed by nodes
+for node in model.data:
+    print(node, model.data[node])
+
+# this is a helper function that reports the cycle lengths 
+# and the  index at wich the cycle started
+model.report_cycles()
+
+#
+# the same thing as above but
+# will not print only return the two parameters
+#
+print(model.detect_cycles())    
+
+#
+# this is how one plots the values, delete this below
+# if matplotlib is not installed
+#
+p1 = pylab.plot( model.data["B"] , 'ob-' )
+p2 = pylab.plot( model.data["C"] , 'sr-' )
+pylab.legend( [p1,p2], ["B","C"])
+pylab.ylim((-0.1,1.1))
+pylab.show()    
+
+
diff --git a/examples/tutorials/t-03.py b/examples/tutorials/t-03.py
index 4316e58..2e997fd 100644
--- a/examples/tutorials/t-03.py
+++ b/examples/tutorials/t-03.py
@@ -1,48 +1,48 @@
-import boolean2
-from boolean2 import Model
-
-#
-# Random sampling of initial conditions
-#
-# If A is set to False, a steady state is obtained.
-#
-# 
-text = """
-A = True
-B = Random
-C = Random
-D = Random
-
-B* = A or C
-C* = A and not D
-D* = B and C
-"""
-
-seen = {}
-
- 
-#
-# the key will be the fingerprint of the first state 
-#(some random inital conditions may be the same), it is fine to overwrite in this case
-# as the 'sync' update rule is completely deterministic
-#
-for i in range(10):
-    model = Model( text=text, mode='sync')
-    model.initialize()
-    model.iterate( steps=20 )
-
-    # detect the cycles in the states
-    size, index = model.detect_cycles() 
-    
-    # fingerprint of the first state
-    key = model.first.fp()
-
-    # keep only the first 10 states out of the 20
-    values = [ x.fp() for x in model.states[:10] ]
-
-    # store the fingerprinted values for each initial state
-    seen [ key ] = (index, size, values )
-
-# print out the observed states
-for first, values in seen.items():
-    print 'Start: %s -> %s' % (first, values)
+import boolean2
+from boolean2 import Model
+
+#
+# Random sampling of initial conditions
+#
+# If A is set to False, a steady state is obtained.
+#
+# 
+text = """
+A = True
+B = Random
+C = Random
+D = Random
+
+B* = A or C
+C* = A and not D
+D* = B and C
+"""
+
+seen = {}
+
+ 
+#
+# the key will be the fingerprint of the first state 
+#(some random inital conditions may be the same), it is fine to overwrite in this case
+# as the 'sync' update rule is completely deterministic
+#
+for i in range(10):
+    model = Model( text=text, mode='sync')
+    model.initialize()
+    model.iterate( steps=20 )
+
+    # detect the cycles in the states
+    size, index = model.detect_cycles() 
+    
+    # fingerprint of the first state
+    key = model.first.fp()
+
+    # keep only the first 10 states out of the 20
+    values = [ x.fp() for x in model.states[:10] ]
+
+    # store the fingerprinted values for each initial state
+    seen [ key ] = (index, size, values )
+
+# print out the observed states
+for first, values in list(seen.items()):
+    print('Start: %s -> %s' % (first, values))
diff --git a/examples/tutorials/t-04.py b/examples/tutorials/t-04.py
index 5105f90..ae334c6 100644
--- a/examples/tutorials/t-04.py
+++ b/examples/tutorials/t-04.py
@@ -1,67 +1,67 @@
-import boolean2
-from boolean2 import util
-
-
-#
-# Modifying states within a program
-#
-# Knocking node B out.
-#
-# Instead of a cycle, now a steady state is observed.
-# 
-# Code is identical to tutorial 3 after the state modification steps
-#
-
-text = """
-A = True
-B = Random
-C = Random
-D = Random
-
-B* = A or C
-C* = A and not D
-D* = B and C
-"""
-
-
-#
-# these nodes will be overexpressed (initialized to True)
-#
-on  = []
-
-#
-# these nodes will be set to false and their corresponding updating 
-# rules will be  removed
-#
-off = ["B"]
-
-#
-# this modifies the original states to apply to overexpressed and knockouts
-#
-text = boolean2.modify_states(text, turnon=on, turnoff=off)
-
-#
-# see tutorial 3 for more details on what happens below
-#
-
-seen = {}
-
-for i in range(10):
-    model = boolean2.Model( text, mode='sync')
-    model.initialize()
-    model.iterate( steps=20 )
-
-    size, index = model.detect_cycles() 
-    
-    # fingerprint of the first state
-    key = model.first.fp()
-
-    # keep only the first 10 states out of the 20
-    values = [ x.fp() for x in model.states[:10] ]
-
-    # store the fingerprinted values for each initial state
-    seen [ key ] = (index, size, values )   
-
-# print out the observed states
-for first, values in seen.items():
-    print 'Start: %s -> %s' % (first, values)
\ No newline at end of file
+import boolean2
+from boolean2 import util
+
+
+#
+# Modifying states within a program
+#
+# Knocking node B out.
+#
+# Instead of a cycle, now a steady state is observed.
+# 
+# Code is identical to tutorial 3 after the state modification steps
+#
+
+text = """
+A = True
+B = Random
+C = Random
+D = Random
+
+B* = A or C
+C* = A and not D
+D* = B and C
+"""
+
+
+#
+# these nodes will be overexpressed (initialized to True)
+#
+on  = []
+
+#
+# these nodes will be set to false and their corresponding updating 
+# rules will be  removed
+#
+off = ["B"]
+
+#
+# this modifies the original states to apply to overexpressed and knockouts
+#
+text = boolean2.modify_states(text, turnon=on, turnoff=off)
+
+#
+# see tutorial 3 for more details on what happens below
+#
+
+seen = {}
+
+for i in range(10):
+    model = boolean2.Model( text, mode='sync')
+    model.initialize()
+    model.iterate( steps=20 )
+
+    size, index = model.detect_cycles() 
+    
+    # fingerprint of the first state
+    key = model.first.fp()
+
+    # keep only the first 10 states out of the 20
+    values = [ x.fp() for x in model.states[:10] ]
+
+    # store the fingerprinted values for each initial state
+    seen [ key ] = (index, size, values )   
+
+# print out the observed states
+for first, values in list(seen.items()):
+    print('Start: %s -> %s' % (first, values))
\ No newline at end of file
